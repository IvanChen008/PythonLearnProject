什么才算真正的编程能力？
(摘自：知乎周刊《编程小白学Python》--家飞猫)
编程能力是一种解决问题的能力。如果问题没有能被很好地解决，知道再多也没有用。

    编程能力是一种运用机器解决问题的能力。首先要判断问题在什么程度上可被机器解决，比如理论计算机科学会告诉我们
什么可做、什么理论上可做实践上不可做。然后是让机器更好地理解问题，比如计算机都是(图灵-冯诺依曼)等价，但不同的问题
可能会使用不同的编程语言。再后是让机器能更高效地解决问题，比如同样的问题可能会有效率差别巨大的算法。
    编程能力是一种问题抽象的能力。能借用轮子是很好的办法，省力省时间。(程序员所说的[轮子]是什么东西？创造它有什么
意义？-知乎http://www.zhihu.com/question/21818673)今天任何软件工程师都会有意无意地使用很多轮子，从操作系统、
编译器、数据库、网络到算法、数据结构。想高效的借用轮子，就需要将问题分解再分解，抽象在抽象。任何一个实用的系统
(不包括教科书上的示例程序和简单的脚本程序)都需要进行大量的分拆和组合。所以系统设计师编程能力里的高级技能，加合理
的假设简化问题尤其有难度，此处不展开讨论。高手和新手的区别在于新手往往不知道轮子的适用范围，而高手的手上轮子数量多
且熟知各种轮子的差异，所以对不同的问题可以轻松地找到合适的轮子，当实在找不到合适的轮子时可以自己动手改造现有的轮子
平时有时间拆装和改造已有的轮子会怼水平提升有较大的帮助。当然能知道怎样快速在搜索引擎里搜出轮子也是一种能力。
    编程能力是一种需要考虑扩展性的能力。算法竞赛中的很多算法考虑的是单机的内存算法，计算模型经过高度抽象，在实践中
机器的模型更为复杂。比如单机的多级结构带来的各种时间空间复杂度的取舍平衡，多机网络中如何能在提高单机性能外进一步
优化整体性能。除了在机器端的扩展，在程序员一端的扩展也很重要。复杂的问题和工程往往意味着团队协同以及更长时间的开发
维护，团队分工和设计沟通这里暂且不论。举个容易被忽视的例子，程序中的注释。高手会更在意完整且表达清楚的注释，因为
这是写给现在和未来的团队(包括自己和其他团队成员)看的，直接影响到长期的整体开发维护效率。
    编程能力是一种取舍的能力。局部的最优解未必是全局的最优解。如果一个美妙的解决方案需要将完工时间向后推迟一两个月，
需要考虑是否先使用平凡方案解决问题，之后在进行优化。当你的工作延后会阻碍别人的工作时尤其如此。发现一个绝妙的优化方
案时先想想这个优化是否真的有价值，如果只是系统中很小的部分，那么不要为了追求心里满足而花很多时间放一个漂亮的轮子上
去(参考Amdahl定律)。
    编程能力是一种预见未来的能力。目前的方案有哪些假设和局限性，在何种情形下会遇到问题甚至崩溃。在未来出现问题时
问题是否需要重新定义，系统是否需要重新设计，代码是否需要重构或优化等等都需要未雨绸缪。
    编程能力是一种工程能力。无它，唯手熟尔。
    编程能力是一种解决问题的能力。如果问题没有能被很好地解决，知道再多也没有用。
    编程能力是一种解决问题的能力。如果问题没有能被很好地解决，知道再多也没有用。


C语言和Python选择那个？

    C标准委员会写的C语言基本原理(http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf)中谈到C
的设计精神，有一句话：
        Make it fast, even if it is not guaranteed to be portable.
    因此，C语言的设计首先要适应机器直觉，其次才是适应人的直觉。与C相反，Python的设计理念无所不用其极地适应人的
直觉，所以获得了[可以执行的伪代码]的美誉。

python的哲学：
    用一种方法，最好是只有一种方法来做一件事。


需要警惕的事情：
    对于初学者而言，起步阶段极易走火，或者在选择Python版本时徘徊不决，一会儿看Python2.7一会儿又转到3.0，或者徜
徉在类库的大海中无法自拔，Scrapy，Numpy，Django什么都要试试，或者参与编辑器圣战、大括号缩进探究、操作系统辩论赛
等无意义活动，或者整天跪舔语法糖，老想怎么一行代码把所有的事情做完，或者去构想圣洁的性能安全通用型健壮性全部满分
的解决方案。
    很多[大牛]都会告诫初学者，用这个用那个，少走弯路，这样反而把初学者推向了真正的弯路。
    还不如告诉初学者，学习本来就需要你去走出弯路出bug，只能脚踏实地，没有奇迹只有狗屎的过程。
    选择一个方向先走下去，哪怕脏丑差，走不动了再看看有没有更好的解决途径。
    自己走了弯路，你才知道这么做的好处，才能理解为什么人们可以手写状态机去匹配却偏要发明正则表达式，为什么面过程
可以解决却偏要面向对象，为什么我可以操纵每一个指针却偏要自动管理内存，为什么我可以嵌套回调却偏要Promise...
    更重要的是，你会明白，高层次的解决方法都是对低层次的封装，并不是任何情况下都是最有效最合适的。
    技术涌进就像波浪一样，那些陈旧的封存已久的技术，消退了迟早还会涌回来。就像现在的移动端应用、手游和HTML5的火热，
某些方面不正在重演过去PC的那些历史吗？
    所以完全不要担心走错路误了终身，坚持并保持进步才是正道。

起步阶段：
    起步阶段的核心任务是掌握硬知识，软知识做了适当了解，有了稳固的根，粗壮的枝干，才能长出浓密的叶子，结出甜美的
果实。完成基础知识的学习，必定会感到一阵空虚，怀疑这些语法知识是不是真的有用。没错，怀疑是正确的，要让Python发挥
它的价值，当然不能停留在语法层面。下一个阶段发展阶段的核心任务，就是[跳出Python 拥抱世界]。 

发展阶段：
    在你面前会有多个分支：科学计算和数据分析、爬虫、web网站、游戏、命令行使用工具等等，这些都不是仅仅知道Python
语法就能解决的问题。
    拿爬虫举个例子，如果你对计算机网络，HTTP协议，HTML，文本编码，JSON一无所知，你能做好这份工作吗？而你在起步
阶段的基础知识也同样重要，如果你连循环递归怎么写都要查文档，连BFS都不知道怎么实现，就像工匠做石凳每次起锤都要思
考锤子怎么使用一样，非常低效。发展阶段必要的会接触大量类库，阅读大量书籍的。
    (至于相关类库如何使用，必须掌握的技能便是阅读文档。由于开源社区大多数文档都是英文写成的，所以英文不好就需要
恶补了。)
    其实你会发现，爬虫大部分讲的不是Python，而更多的是专业知识。事实上，这里所谓[跳出Python 拥抱世界]，其实就会
发现Python和专业知识结合，能够解决很多实际问题。这个阶段能走到什么程度，更多地取决于自己的专业知识。

深入阶段:
    进入这个阶段的你,对Python几乎了如指掌,那么你一定知道Python是用C语言实现的。可是Python对象的动态特征是怎么用
相对底层，连自动内存管理都没有的C语言实现的呢|？ 这时候就不能停留在表面了，勇敢的打开Python的黑盒子，深入到语言的
内部去，去看它的历史，读它的源码，才能真正的理解它的设计思路。
    (这里推荐一本书：Python源码剖析(http://book.douban.com/subject/3117898/))
    这本书对Python源码最核心的部分，给出了详细的阐释，不过阅读此书需要对C语言内存模型和指针有很好的理解。
    另外，Python是一门杂糅多种范式的动态语言，也就是说，相对于C的过程式、Schema和Haskell等函数式、Java基于类的
面向对象而言，它都不纯粹。换言之，编程语言的[道学]，在Python中，只能有限的体悟。学习某种编程范式时，从那些面向这种
范式更加纯粹的语言出发，才能有更加深刻的理解，也能了解到Python语言的根源。
    (这里推荐一门斯坦福大学的公开课：[编程范式]http://v.163.com/special/opencourse/paradigms.html)
    值得一提的是，这门课程对C语言有非常深入的讲解，例如C语言的范型和内存管理。这些知识，对阅读Python源码有很大的帮助。
    其实Python许多最佳实践都隐藏在那些众所周知的框架和类库中，阅读它们的源码也是个不错的选择。


结语：
    每个人学编程道路都不一样，其实大多都殊途同归，没有迷路的人只有不能坚持的人。0




python解释器参数传递：
    调用解释器时，脚本名和附加参数传入一个名为sys.argv的字符串列表。你能够获得这个列表通过执行 import sys,
    列表长度大于等于1；没有给定脚本和参数时，它至少也有一个元素：sys.argv[0]此时为空字符串。脚本名指定为'-'
    （表示标准输入）时，sys.argv[0]被设定为'-'，使用-c指令时，sys.argv[0]被设定为'-c'。使用'-m'模块参数时，
    sys.argv[0]被设定为指定模块的全名。-c 指令 或者 -m 模块 之后的参数不会被 Python 解释器的选项处理机制所
    截获，而是留在 sys.argv 中，供脚本命令操作。

数字：
    除法(/)永远返回一个浮点数。如要使用floor除法并且得到整数结果(丢掉任何小数部分)，可以使用(//)运算符。计算
    余数可以使用(%)。
    交互模式中，最近一个表达式的值赋给变量 _。这样我们就可以把它当作一个桌面计算器，很方便的用于连续计算，此变
    量对于用户是只读的。不要尝试给它赋值 —— 你只会创建一个独立的同名局部变量，它屏蔽了系统内置变量的魔术效果。

条件控制：
    while 和 if 语句中使用的条件不仅可以使用比较，而且可以包含任意的操作。
    比较操作符 in 和 not in 审核值是否在一个区间之内。
    操作符 is 和 is not 比较两个对象是否相同；这只和诸如列表这样的可变对象有关。所有的比较操作符具有相同的优先
    级，低于所有的数值操作。比较操作可以传递。例如 a < b == c 审核是否 a 小于 b 并且 b 等于 c。
    比较操作可以通过逻辑操作符 and 和 or 组合，比较的结果可以用 not 来取反义。这些操作符的优先级又低于比较操作符，
    在它们之中，not 具有最高的优先级， or 优先级最低，所以 A and not B or C 等于 (A and (notB)) or C。当然，
    括号也可以用于比较表达式。
    逻辑操作符 and 和 or 也称作短路操作符：它们的参数从左向右解析，一旦结果可以确定就停止。例如，如果 A 和 C 为真
    而 B 为假， A and B and C 不会解析 C。作用于一个普通的非逻辑值时，短路操作符的返回值通常是最后一个变量。

    序列对象可以与相同类型的其它对象比较。比较操作按 字典序 进行：首先比较前两个元素，如果不同，就决定了比较的结果；
    如果相同，就比较后两个元素，依此类推，直到所有序列都完成比较。如果两个元素本身就是同样类 型的序列，就递归字典序
    比较。如果两个序列的所有子项都相等，就认为序列相等。如果一个序列是另一个序列的初始子序列，较短的一个序列就小于
    另一个。字符串的字典序按照单字符的 ASCII 顺序。
    需要注意的是如果通过 < 或者 > 比较的对象只要具有合适的比较方法就是合法的。比如，混合数值类型是通过它们的数值进
    行比较的，所以 0 是等于 0.0 。否则解释器将会触发一个 TypeError 异常，而不是提供一个随意的结果。

模块：
    如果推出Python解释器并重新输入，之前做的任何定义（变量和方法）都会丢失。因此，如果你想要编写一些更大的程序，为
准备解释器输入使用一个文本编辑器会更好，并以那个文件替代作为输入执行。这就是传说中的脚本。随着你的程序变得越来越长，
你可能想要将它分割成几个更容易维护的文件。你也可能想在不同的程序中使用顺手的函数，而不是把代码在它们之间拷来拷去。
    为了满足这些需求，Python提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互实例中使用。这样的文件被
称为模块；模块中的定义可以导入到另一个模块或者主模块中(在脚本执行时可以调用的变量集位于更高级，并且处于计算器模式。)
    模块时包括Python定义和声明的文件。文件名就是模块名加上 .py 后缀。模块的模块名(作为一个字符串)可以由全局变量
__name__ 得到。
    除了包含函数定义外，模块也可以包含可执行语句。这语句一般用来初始化模块。它们仅在第一次被导入的地方执行一次。每一
个模块都有自己的私有符号表，被模块内所有的函数定义作为全局符号表使用。因此，模块的作者可以在模块内部使用全局变量，而
不需担心它与某个用户的全局变量意外冲突。从另一个方面讲，如果你确切的知道自己在做什么，你可以使用引用模块函数的表示法
访问模块的全局变量，modname.itemname。
    模块可以导入其他的模块。一个（好的）习惯是将所有的 import 语句放在模块的开始（或者是脚本），这并非强制。被导入
的模块名会放入当前模块的全局符号表中。

    作为脚本来执行模块：
        当你用一下方式运行python模块时，模块中的代码便会被执行，模块中的代码会被执行，就像导入一样，不过此时__name__
    被设置为"__main__"。
    这相当于，如果你在模块后加入如下代码：
    =================================
    if __name__ == "__main__":
        import sys
        pass 
    =================================
    就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为"__main__"文件执行时才被调用。如果模块被导入
    是不会执行这段代码的。这通常用来为模块提供一个便于测试的用户接口(将模块作为脚本执行测试需求)。 
    
    模块搜索的路径：
        导入一个叫 spam 的模块时，解释器先在当前目录中搜索名为 spam.py 的文件。如果没有找到的话，接着会到 sys.path 
        变量中给出的目录列表中查找。 sys.path 变量的初始值来自如下：
            1、输入脚本的目录（当前目录）。
            2、环境变量 PYTHONPATH 表示的目录列表中搜索(这和 shell 变量 PATH 具有一样的语法，即一系列目录名的列表)。
            3、Python 默认安装路径中搜索。
        (在支持符号连接的文件系统中，输入的脚本所在的目录是符号连接指向的目录。 换句话说也就是包含符号链接的目录不会被
        加到目录搜索路径中。)
    实际上，解释器由 sys.path 变量指定的路径目录搜索模块，该变量初始化时默认包含了输入脚本（或者当前目录），PYTHONPATH 
    和安装目录。这样就允许 Python 程序了解如何修改或替换模块搜索目录。需要注意的是由于这些目录中包含有搜索路径中运行的
    脚本，所以这些脚本不应该和标准模块重名，否则在导入模块时 Python 会尝试把这些脚本当作模块来加载。这通常会引发错误。

    "编译的"python 文件：
        为了加快加载模块的速度，Python 会在 __pycache__ 目录下以 module.version.pyc 名字缓存每个模块编译后的版本，
    这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。这种命名约定允许由不同发布和不同版本的 Python 编译
    的模块同时存在。
        Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。这是完全自动化的过程。同时，编译后的模块是
    跨平台的，所以同一个库可以在不同架构的系统之间共享。
        Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。其次，如果没有
    源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。
        部分高级技巧:
            为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO。-O 参数删除了断言语句，-OO 参数删除
        了断言语句和 __doc__ 字符串。
            因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。“优化的” 模块有一个 .pyo 后缀而不是
         .pyc 后缀。未来的版本可能会改变优化的效果。

            来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快；.pyc 或 .pyo 文件只是在它们加载的时候更快一些。

            compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。

            在 PEP 3147 中有很多关这一部分内容的细节，并且包含了一个决策流程。
    
    标准模块
    python带有一个标准模块库，并发布有独立的文档，名为 Python 库参考手册（此后称其为“库参考手册”）。有一些模块内置于解释
器之中，这些操作的访问接口不是语言内核的一部分，但是已经内置于解释器了。这既是为了提高效率，也是为了给系统调用等操作系统原生
访问提供接口。这类模块集合是一个依赖于底层平台的配置选项。
    变量 sys.path 是解释器模块搜索路径的字符串列表。它由环境变量 PYTHONPATH 初始化，如果没有设定 PYTHONPATH ，就由内置
的默认值初始化。你可以用标准的字符串操作修改它:
    =====================================
    >>> import sys
    >>> sys.path.append('/ufs/guido/lib/python')
    =====================================

包：
    包通常是使用用“圆点模块名”的结构化模块命名空间。例如，名为 A.B 的模块表示了名为 A 的包中名为 B 的子模块。正如同用模块
来保存不同的模块架构可以避免全局变量之间的相互冲突，使用圆点模块名保存像 NumPy 或 Python Imaging Library 之类的不同类库
架构可以避免模块之间的命名冲突。

    导入包：
    当你导入一个包时，Python 通过 sys.path 搜索路径查找包含这个包的子目录。为了让 Python 将目录当做内容包，目录中必须包含
 __init__.py 文件。这是为了避免一个含有烂俗名字的目录无意中隐藏了稍后在模块搜索路径中出现的有效模块，比如 string。最简单的
 情况下，只需要一个空的 __init__.py 文件即可。当然它也可以执行包的初始化代码，或者定义 __all__ 变量。
    方式：
        import package.module.submodule
        这样就加载了 package.module.submodule 子模块了，他需要通过完整的名称来引用。
        from package.module import item
        这样就是加载了 item 子模块，并且使得它在没有包前缀的情况下也可以使用，所以它可以直接用item来调用模块。    
        from package.module.item import function_or_variable
        这样可以直接导入函数或变量，这样就又一次加载了 item 子模块，但这样就可以直接调用它的 function_or_variable 函数或变量。

    需要注意的是使用 from package import item 方式导入包时，这个子项（item）既可以是包中的一个子模块（或一个子包），也可以
是包中定义的其它命名，像函数、类或变量。import 语句首先核对是否包中有这个子项，如果没有，它假定这是一个模块，并尝试加载它。如
果没有找到它，会引发一个 ImportError 异常。
    相反，使用类似 import item.subitem.subsubitem 这样的语法时，这些子项必须是包，最后的子项可以是包或模块，但不能是前面
子项中定义的类、函数或变量。